# mocking HTTP requests

## Background

Testing that our frontend code interacts with the backend is important. It's how
the user uses our applications, so it's what our tests should do as well if we
want the maximum confidence. However, there are several challenges that come
with doing that. The setup required to make this work is non-trivial. It is
definitely important that we test that integration, but we can do that with a
suite of solid E2E tests using a tool like [Cypress](https://cypress.io).

For our Integration and Unit component tests, we're going to trade-off some
confidence for convenience and we'll make up for that with E2E tests. So for all
of our Jest tests, we'll mock out `window.fetch` so we can have it return a fake
value for our tests. Then we can assert that `window.fetch` was at least called
correctly.

We've actually already gotten that set up in our test setup file:

```javascript
// ./test/setup.js
beforeEach(() => {
  window.fetch = jest.fn((...args) => {
    console.warn('window.fetch is not mocked for this call', ...args)
    return Promise.reject(new Error('This must be mocked!'))
  })
})
```

> Because window.fetch isn't supported in JSDOM/Node, we can simply assign it to
> a mock function. Normally, it's better to use jest.spyOn
> (https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname) because
> that allows you to use `mockRestore()` as a cleanup
> (https://jestjs.io/docs/en/mock-function-api#mockfnmockrestore)

With `fetch` mocked in this way, our tests can mock `fetch` calls like this:

```javascript
window.fetch.mockImplementationOnce((method, config) => {
  // you can use the method and config if you need
  // then you return what would normally be returned from this call:
  return Promise.resolve({
    json: () => Promise.resolve({data: 'some awesome data!'}),
  })
})

// there are several other helpers you can use like:
// - mockReturnValue
// - mockResolvedValueOnce
// - mockRejectedValue
// etc...
```

That will make it so the next time our code calls `window.fetch` it will get a
promise that resolves to an object with a json function which returns a promise
that resolves to our data.

In a real-world application, I recommend mocking fetch in a single place with
handlers for all of your app's endpoints so you don't have to bother mocking
fetch in each individual test (unless there's a specific need). This is not easy
to get going at first, but once you have it in place it's really powerful and
allows you to test without much trouble. You can see an example of this here:
https://github.com/kentcdodds/bookshelf/blob/bdcc1942ff3c70e8dd1e5717bb99886e28846107/src/test/fetch-mock.js

## Exercise

In the last exercise you wrote a test for the Login form by itself, now you'll
be writing a test that connects that login form with a backend request for when
the user submits the form.

Note, this is the first exercise where we'll be using a `find*` query variant
because the `loading` indicator shows up asynchronously.

ðŸ“œ Read about the `findBy` query variant:
https://testing-library.com/docs/dom-testing-library/api-queries#findby

## Extra Credit

### 1. ðŸ’¯ reuse server request handlers

In my applications, I love having a mock server to use during development. It's
often more reliable, works offline, doesn't require a lot of environment setup,
and allows me to start writing UI for APIs that aren't finished yet.

MSW was actually originally built for this use case and we've already
implemented this server handler for our app in `test/server-handlers.js`, so for
this extra credit, import that array of server handlers and send it along into
the `setupServer` call.

### 2. ðŸ’¯ test the unhappy path

Add a test for what happens if the response to our login request is a failure.
Our server handlers already handle situations where the username or password are
not provided, so you can simply not fill one of those values in and then you'll
want to make sure the error message is displayed.

### 3. ðŸ’¯ use inline snapshots for error messages

Copy and pasting output into your test assertion (like the error message in our
last extra credit) is no fun. Especially if that error message were to change in
the future.

Instead, we can use a special assertion to take a "snapshot" of the error
message and Jest will update our code for us. Use `toMatchInlineSnapshot` rather
than an explicit assertion on that error element.

ðŸ“œ [Snapshot Testing](https://jestjs.io/docs/en/snapshot-testing)

### 4. ðŸ’¯ use one-off server handlers

How would we test a situation where the server fails for some unknown reason?
There are plenty of situations where we want to test what happens when the
_server_ misbehaves. But we don't want to code those scenarios in our
application-wide server handlers for two reasons:

1. It clutters our application-wide handlers. Lots of the same problems of CSS
   applies here: people are afraid to modify or delete any code because they're
   uncertain what other code will break as a result.
2. The indirection makes the tests harder to understand.

[Read more about the benefits of colocation](https://kentcdodds.com/blog/colocation).

So instead, we want one-off server handlers to be written directly in the test
that needs it. This is what MSW's `server.use` API is for. It allows you to add
server handlers after the server has already started. And the
`server.resetHandlers()` allows you to remove those added handlers between tests
to preserve test isolation and restore the original handlers.

See if you can add another test to check a situation for when the server
misbehaves and sends a status code 500 error.

ðŸ’° Here's something to get you started:

```javascript
server.use(
  rest.post(
    // note that it's the same URL as our app-wide handler
    // so this will override the other.
    'https://auth-provider.example.com/api/login',
    async (req, res, ctx) => {
      // your one-off handler here
    },
  ),
)
```

## ðŸ¦‰ Elaboration and Feedback

After the instruction, if you want to remember what you've just learned, then
fill out the elaboration and feedback form:

https://ws.kcd.im/?ws=Testing%20React%20Applications%20%F0%9F%A7%90&e=05%3A%20mocking%20HTTP%20requests&em=
